#!/usr/bin/env python3

import sys
import subprocess
import shutil
import cantools
import re
from pathlib import Path


SCRIPT_DIR = Path(__file__).resolve().parent
ROOT = SCRIPT_DIR.parent
BUILD = ROOT / "build"

INPUTS = [
    ROOT / "networks" / "can0_powertrain.dbc",
    ROOT / "networks" / "can1_data.dbc",
]

GEN_LINE_RE = re.compile(
    r"^( \* @brief .* generated by cantools version [0-9.]+).*$")


def debug_info():
    print(SCRIPT_DIR)
    print(ROOT)


# Invokes a subprocces to run commands via CLI
def run(cmd: list[str], *, stdout=None) -> None:
    print(">", " ".join(cmd))
    subprocess.check_call(cmd, stdout=stdout)


def generate_c_source(dbc: Path, out_dir: Path) -> Path:
    can_id = dbc.stem
    out = out_dir / str(can_id)
    run(["cantools", "generate_c_source", str(dbc), "-o", str(out)])
    return out


# Create a log file, with CAN outputs.
def generate_log(dbc: Path, out_dir: Path) -> Path:
    can_id = dbc.stem
    out = out_dir / can_id / f"{can_id}.txt"
    out.parent.mkdir(parents=True, exist_ok=True)

    with out.open("w") as f:
        run(["cantools", "dump", str(dbc)], stdout=f)

    return out


# check if any CAN frames share the same ID
def assert_no_duplicate_frame_ids(dbc: Path) -> None:
    db = cantools.database.load_file(dbc)

    seen: dict[int, str] = {}
    duplicates: list[tuple[int, str, str]] = []

    for msg in db.messages:
        fid = msg.frame_id
        if fid in seen:
            duplicates.append((fid, seen[fid], msg.name))
        else:
            seen[fid] = msg.name

    if duplicates:
        details = ", ".join([f"0x{fid:X} ({a} vs {b})" for fid, a, b in duplicates])
        raise ValueError(f"Duplicate CAN frame IDs in {dbc}: {details}")


def sanitize_generated_file(path: Path) -> None:
    lines = path.read_text().splitlines(True)
    new_lines = []
    for line in lines:
        m = GEN_LINE_RE.match(line)
        if m:
            # keep version, remove timestamp
            new_lines.append(m.group(1) + ".\n")
        else:
            new_lines.append(line)
    path.write_text("".join(new_lines))


def sanitize_tree(out_dir: Path) -> None:
    for p in out_dir.rglob("*"):
        if p.suffix in (".h", ".c"):
            sanitize_generated_file(p)


# Generates build files
def build(inputs, out_dir: Path):
    print("[canbuild] Starting build process...")
    clean(out_dir)
    out_dir.mkdir(exist_ok=True)

    write_readme(out_dir)

    # check if input is a single path -> set to iterable instance
    if isinstance(inputs, (str, Path)):
        inputs = [Path(inputs)]

    for dbc in inputs:
        # List all messages, throws exception early if any errors occur
        print(f"[canbuild] Building: `{dbc}`...")
        run(["cantools", "list", str(dbc)])

        lint(dbc)

        out = generate_c_source(dbc, out_dir)
        sanitize_tree(out)  # added to remove auto generated timestamps
        print(f"[canbuild] Source files generated {out}...")

        out = generate_log(dbc, out_dir)
        print(f"[canbuild] Log generated: {out}...")


# Verifies .dbc files, does not generate build files
def lint(dbc: Path) -> None:
    if not dbc.exists():
        raise FileNotFoundError(dbc)

    try:
        assert_no_duplicate_frame_ids(dbc)
    except Exception:
        print(f"[canbuild] [FAIL]: {dbc.name}")
        raise

    print(f"[canbuild] [PASS]: {dbc.name}")


# Deletes the build folder, and removes build artifacts
def clean(out_dir: Path):
    shutil.rmtree(out_dir, ignore_errors=True)
    print("[canbuild] Deleted build folder...")


def write_readme(out_dir: Path) -> None:
    readme = out_dir / "README.md"
    readme.write_text(
        "# CAN Database - Auto-genertated\n\n"
        "This directory contains auto-generated C headers and sources "
        "produced from the CAN `.dbc` files in `networks/`.\n\n"
        "## Important\n\n"
        "- **Do not edit these files by hand**\n"
        "- These files are generated by `tools/canbuild.py`\n"
        "- The `.dbc` files are the **source of truth**\n\n"
        "## Updating generated files\n\n"
        "If you modify a `.dbc` file, you must update `include/`.\n\n"
        "```bash\n"
        "python tools/canbuild.py build --out include\n"
        "git add include\n"
        "git commit -m \"Update generated CAN interface\"\n"
        "```\n"
    )


def main():
    if len(sys.argv) < 2:
        print("Usage: canbuild.py [build|lint|clean]")
        sys.exit(1)

    cmd = sys.argv[1]

    out_dir = BUILD
    if "--out" in sys.argv:
        i = sys.argv.index("--out")
        out_dir = (ROOT / sys.argv[i + 1]).resolve()

    if cmd == "build":
        build(INPUTS, out_dir)

    elif cmd == "lint":
        if len(sys.argv) < 3:
            print("Usage: canbuild.py lint <dbc_path>")
        lint((ROOT / sys.argv[2]).resolve())

    elif cmd == "clean":
        clean(BUILD)

    print("[cantools] Exiting.")


if __name__ == "__main__":
    debug_info()
    main()
